{
  "hash": "7e8c0b12931d79563773dae80ac97845",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 3 Solutions: Coordinates and Geometries\"\n---\n\n\n\n\n<span style=\"color:#9F281A;\"> 1. Write out the pseudocode that you would use to set up an analysis of the spatial correlations between chronic asthma risk, exposure to PM2.5, and wildfire. You don't have to write functions or any actual code. Just write the steps and insert named code blocks for each step.</span>\n\n>This one is probably a little tricky if you haven't taken the time to check out the attributes of the data (which you should _always_ do). That said, some pretty generic steps would be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1. Load each dataset\n2. Check geometry validity\n3. Align CRS\n4. Run Correlation\n5. Print Results\n```\n:::\n\n\n>There are two **key steps** here, that you'll repeat for any/all spatial analyses that you do: 1) checking for valid geometries and 2) making sure the data are aligned in a sensible CRS. I can add a code chunk for each now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1. Load each dataset\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n2. Check geometry validity\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n3. Align CRS\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n4. Run Correlation\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n5. Print Results\n```\n:::\n\n\n<span style=\"color:#9F281A;\">2. Read in the `cdc_nw.shp`, `pm_nw.shp`, and `wildfire_hazard_agg.tif` files and print the coordinate reference system for each object. Do they match?</span>\n\n>Here I'm going to combine the `load` portion of my pseudocode with the `validity` since I can do that without creating additional object. I use the `str()` function to get a sense for what the data looks like and to understand what data classes I'm working with. Then, I use the `all()` function to make sure that all of the results of `st_is_valid()` are true. I don't need to do that with the raster file as the geometry is implicit which means that it has to be topologically valid (this doesn't mean that the numbers are accurate, it just means that the dataset conforms to the data model `R` expects). Then I'll add another code to check the `CRS` of the different objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(terra)\nlibrary(tidyverse)\n\ncdc.nw <- read_sf(\"data/opt/data/2023/assignment03/cdc_nw.shp\")\nstr(cdc.nw)\nall(st_is_valid(cdc.nw))\npm.nw <- read_sf(\"data/opt/data/2023/assignment03/pm_nw.shp\")\nstr(pm.nw)\nall(st_is_valid(pm.nw))\n\nwildfire.haz <- rast(\"data/opt/data/2023/assignment03/wildfire_hazard_agg.tif\")\nstr(wildfire.haz)\n```\n:::\n\n\n\n>Now that I've gotten the data into my environment, I need to make sure that the CRS are aligned. I'll demonstrate that with a few different approaches. You can use the logical `==` or the `identical` function to check, but remember that these functions are not specific to spatial objects, they evaluate things very literally. So even if the CRS is the same, if `st_crs` returns the CRS in one format (`WKT`) and `crs` returns it in another, you'll get `FALSE` even if they are actually the same CRS - pay attention to that. You'll notice that they aren't identical; we'll deal with that in the next question.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(cdc.nw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: NAD83 \n  wkt:\nGEOGCRS[\"NAD83\",\n    DATUM[\"North American Datum 1983\",\n        ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4269]]\n```\n\n\n:::\n\n```{.r .cell-code}\nst_crs(pm.nw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: WGS 84 / Pseudo-Mercator \n  wkt:\nPROJCRS[\"WGS 84 / Pseudo-Mercator\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"Popular Visualisation Pseudo-Mercator\",\n        METHOD[\"Popular Visualisation Pseudo Mercator\",\n            ID[\"EPSG\",1024]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"False easting\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Web mapping and visualisation.\"],\n        AREA[\"World between 85.06°S and 85.06°N.\"],\n        BBOX[-85.06,-180,85.06,180]],\n    ID[\"EPSG\",3857]]\n```\n\n\n:::\n\n```{.r .cell-code}\ncrs(wildfire.haz)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"PROJCRS[\\\"unnamed\\\",\\n    BASEGEOGCRS[\\\"NAD83\\\",\\n        DATUM[\\\"North American Datum 1983\\\",\\n            ELLIPSOID[\\\"GRS 1980\\\",6378137,298.257222101004,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4269]],\\n    CONVERSION[\\\"Albers Equal Area\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",-96,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",29.5,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",45.5,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"easting\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]],\\n        AXIS[\\\"northing\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]]]\"\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(st_crs(cdc.nw), st_crs(pm.nw))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nst_crs(cdc.nw) == st_crs(pm.nw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n<span style=\"color:#9F281A;\">3. Re-project the `cdc_nw.shp` and `pm_nw.shp` shapefiles so that they have the same CRS as the `wildfire_hazard_agg.tfi` file. Verify that all the files have the same projection.</span>\n\n>Now we'll use `st_transform` to get the two shapefiles aligned with the raster (because we generally want to avoid projecting rasters if we can). We can then use the same steps above to see if they're aligned. Note that I'm using the `terra::crs()` function to make sure that the output is printed in exactly the same format\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncdc.nw.proj <- cdc.nw %>% st_transform(., crs=crs(wildfire.haz))\npm.nw.proj <- pm.nw %>% st_transform(., crs=crs(wildfire.haz))\n\nidentical(crs(cdc.nw.proj), crs(wildfire.haz))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(crs(pm.nw.proj), crs(wildfire.haz))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n<span style=\"color:#9F281A;\">4. How does reprojecting change the coordinates of the bounding box for the two shapefiles? Show your code</span>\n\n>Now we just want to look at the bounding box of the data before and after it was projected. We can do this using `st_bbox`. One of the most obvious changes is that the units for `cdc.nw` have changed from degrees to meters (as evidenced by the much larger numbers). For the `pm.nw` object we can see that the raw coordinates indicate a shift to the west; however, because the origin for this crs has also changed, the states still show up in the correct place.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_bbox(cdc.nw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      xmin       ymin       xmax       ymax \n-124.74918   41.98818 -111.04349   49.00232 \n```\n\n\n:::\n\n```{.r .cell-code}\nst_bbox(cdc.nw.proj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    xmin     ymin     xmax     ymax \n-2295337  2208890 -1189292  3177425 \n```\n\n\n:::\n\n```{.r .cell-code}\nst_bbox(pm.nw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     xmin      ymin      xmax      ymax \n-13898126   5159210 -12361307   6275276 \n```\n\n\n:::\n\n```{.r .cell-code}\nst_bbox(pm.nw.proj)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    xmin     ymin     xmax     ymax \n-2300791  2208891 -1189293  3177426 \n```\n\n\n:::\n:::\n\n\n<span style=\"color:#9F281A;\">5. What class of geometry does the `pm_nw.shp` have (show your code)? Now filter the `pm_nw.shp` file so that only the records from Ada County, Idaho are showing. Find the record with the lowest value for PM25. How many coordinates are associated with that geometry?</span>\n\n>This one was probably a little tricky. First, to check the geometry type, we use `st_geometry_type` setting `by_geometry` to `FALSE` means we get the geometry type for the entire object instead of each observation. We then use a series of `filter` commands to get the records from Idaho and Ada county. Once we've narrowed the data to our correct region, we can `filter` again to find the row with the minimum value of PM25 (note that we have to set `na.rm=TRUE` so that we ignore the NA values). Then we just take the number of rows (`nrow`) of the result of `st_coordinates` to get the number of coordinates associated with that geometry.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_geometry_type(pm.nw, by_geometry = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] MULTIPOLYGON\n18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n```\n\n\n:::\n\n```{.r .cell-code}\nada.pm <- pm.nw %>%\n  filter(STATE_NAME==\"Idaho\" & CNTY_NAME==\"Ada\") %>%\n  filter(PM25 == min(PM25, na.rm = TRUE))\n\nada.pm\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1 feature and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -12935300 ymin: 5329192 xmax: -12910260 ymax: 5402433\nProjected CRS: WGS 84 / Pseudo-Mercator\n# A tibble: 1 × 4\n  STATE_NAME CNTY_NAME  PM25                                            geometry\n* <chr>      <chr>     <dbl>                                  <MULTIPOLYGON [m]>\n1 Idaho      Ada        6.68 (((-12935301 5391002, -12934885 5391290, -12934526…\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(st_coordinates(ada.pm))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1394\n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}